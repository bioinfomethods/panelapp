name: Main workflow, test and deploy to AWS

on:
  push:
    branches:
      - main
      - roo
      - develop

permissions:
  id-token: write
  contents: read

jobs:
  init:
    name: "init"
    runs-on: ubuntu-latest
    steps:
      - name: GitHub Environment Variables Action
        uses: FranzDiebold/github-env-vars-action@v2.8.0

      - id: init_env
        shell: bash
        run: |
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT"
          if [ "$CI_ACTION_REF_NAME_SLUG" == "main" ] || [ "$CI_ACTION_REF_NAME_SLUG" == "master" ] || [ "$CI_ACTION_REF_NAME_SLUG" == "roo" ]; then
            echo "env_name=prod" >> "$GITHUB_OUTPUT"
            echo "github_actions_environment=prod" >> "$GITHUB_OUTPUT"
          elif [ "$CI_ACTION_REF_NAME_SLUG" == "develop" ]; then
            # FIXME: Only temporarily
            echo "env_name=prod" >> "$GITHUB_OUTPUT"
            echo "github_actions_environment=mcri-vcgs-prod" >> "$GITHUB_OUTPUT"
          else
            echo "env_name=test" >> "$GITHUB_OUTPUT"
            echo "github_actions_environment=test" >> "$GITHUB_OUTPUT"
          fi
          echo "env_name=$env_name"
          echo "GITHUB_OUTPUT=$GITHUB_OUTPUT"

      - name: Log outputs
        run: |
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT"
          echo "env_name=${{ steps.init_env.outputs.env_name }}"
          echo "github_actions_environment=${{ steps.init_env.outputs.github_actions_environment }}"

    outputs:
      env_name: ${{ steps.init_env.outputs.env_name }}
      github_actions_environment: ${{ steps.init_env.outputs.github_actions_environment }}

  tests:
    needs: init
    environment: ${{ needs.init.outputs.github_actions_environment }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [ 3.9 ]
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_DB: panelapp
          POSTGRES_USER: panelapp
          POSTGRES_PASSWORD: secret
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U panelapp -d panelapp"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    env:
      POSTGRES_DB: panelapp
      POSTGRES_USER: panelapp
      POSTGRES_PASSWORD: secret
      DATABASE_URL: postgres://panelapp:secret@localhost:5432/panelapp
      DJANGO_SETTINGS_MODULE: panelapp.settings.test
      DJANGO_LOG_LEVEL: INFO
    steps:
      - name: GitHub Environment Variables Action
        uses: FranzDiebold/github-env-vars-action@v2.8.0

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v2
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install dependencies
        run: |
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT"
          sudo apt-get install -y libpq-dev gcc python3-dev
          pip install pip==23.3.2
          pip install .[dev,tests]
          pip install pytest pytest-runner

      - name: Run tests
        run: pytest

  build:
    needs: init
    environment: ${{ needs.init.outputs.github_actions_environment }}
    runs-on: ubuntu-latest

    steps:
      - name: GitHub Environment Variables Action
        uses: FranzDiebold/github-env-vars-action@v2.8.0

      - name: Log inputs
        run: |
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT"
          echo "region=${{ vars.AWS_REGION }}"
          echo "env_name=${{ needs.init.outputs.env_name }}"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          unset-current-credentials: true
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_OIDC_PROVIDER_ROLE }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to Amazon ECR
        id: build_image
        shell: bash
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          export PACKAGE_NAME=$(python setup.py --name)
          export BASE_REPO_NAME="${PACKAGE_NAME}_base_${{needs.init.outputs.env_name}}"
          export WEB_REPO_NAME="${PACKAGE_NAME}_web_${{needs.init.outputs.env_name}}"
          export WORKER_REPO_NAME="${PACKAGE_NAME}_worker_${{needs.init.outputs.env_name}}"
          echo "AWS_REGION=$AWS_REGION"
          echo "PACKAGE_NAME=$PACKAGE_NAME, BASE_REPO_NAME=$BASE_REPO_NAME, WEB_REPO_NAME=$WEB_REPO_NAME, WORKER_REPO_NAME=$WORKER_REPO_NAME"
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT"

          docker build -t "$ECR_REGISTRY/$BASE_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" --file ./docker/cloud/Dockerfile-base .
          docker tag "$ECR_REGISTRY/$BASE_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" "$ECR_REGISTRY/$BASE_REPO_NAME:$CI_SHA_SHORT"
          docker push "$ECR_REGISTRY/$BASE_REPO_NAME:$CI_ACTION_REF_NAME_SLUG"
          docker push "$ECR_REGISTRY/$BASE_REPO_NAME:$CI_SHA_SHORT"
          if [ "${{ needs.init.outputs.env_name }}" != "prod" ]; then
            echo "Tagging latest base image for non-prod environment"
            docker tag "$ECR_REGISTRY/$BASE_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" "$ECR_REGISTRY/$BASE_REPO_NAME:latest"
            docker push "$ECR_REGISTRY/$BASE_REPO_NAME:latest"
          fi

          docker build -t "$ECR_REGISTRY/$WEB_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" --build-arg "BASE_IMAGE=$ECR_REGISTRY/$BASE_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" --file ./docker/cloud/Dockerfile-web .
          docker tag "$ECR_REGISTRY/$WEB_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" "$ECR_REGISTRY/$WEB_REPO_NAME:$CI_SHA_SHORT"
          docker push "$ECR_REGISTRY/$WEB_REPO_NAME:$CI_ACTION_REF_NAME_SLUG"
          docker push "$ECR_REGISTRY/$WEB_REPO_NAME:$CI_SHA_SHORT"
          if [ "${{ needs.init.outputs.env_name }}" != "prod" ]; then
            echo "Tagging latest web image for non-prod environment"
            docker tag "$ECR_REGISTRY/$WEB_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" "$ECR_REGISTRY/$WEB_REPO_NAME:latest"
            docker push "$ECR_REGISTRY/$WEB_REPO_NAME:latest"
          fi
          echo "web_image=$ECR_REGISTRY/$WEB_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" >> "$GITHUB_OUTPUT"

          docker build -t "$ECR_REGISTRY/$WORKER_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" --build-arg "BASE_IMAGE=$ECR_REGISTRY/$BASE_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" --file ./docker/cloud/Dockerfile-worker .
          docker tag "$ECR_REGISTRY/$WORKER_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" "$ECR_REGISTRY/$WORKER_REPO_NAME:$CI_SHA_SHORT"
          docker push "$ECR_REGISTRY/$WORKER_REPO_NAME:$CI_ACTION_REF_NAME_SLUG"
          docker push "$ECR_REGISTRY/$WORKER_REPO_NAME:$CI_SHA_SHORT"
          if [ "${{ needs.init.outputs.env_name }}" != "prod" ]; then
            echo "Tagging latest worker image for non-prod environment"
            docker tag "$ECR_REGISTRY/$WORKER_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" "$ECR_REGISTRY/$WORKER_REPO_NAME:latest"
            docker push "$ECR_REGISTRY/$WORKER_REPO_NAME:latest"
          fi
          echo "worker_image=$ECR_REGISTRY/$WORKER_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" >> "$GITHUB_OUTPUT"
    outputs:
      base_image: ${{ steps.build_image.outputs.base_image }}
      web_image: ${{ steps.build_image.outputs.web_image }}
      worker_image: ${{ steps.build_image.outputs.worker_image }}

  deploy:
    needs: [init, tests, build]
    environment: ${{ needs.init.outputs.github_actions_environment }}
    runs-on: ubuntu-latest
    env:
      TF_VAR_env_name: ${{ needs.init.outputs.env_name }}
      TF_VAR_default_tags: '{"Stack": "panelapp", "Env": "${{ needs.init.outputs.env_name }}"}'
      TF_VAR_region: ${{ vars.AWS_REGION }}
      TF_VAR_account_id: ${{ vars.ACCOUNT_ID }}
      TF_VAR_trusted_account: ${{ vars.ACCOUNT_ID }}
      TF_VAR_admin_email: ${{ vars.ADMIN_EMAIL }}
      TF_VAR_admin_url: ${{ vars.ADMIN_URL }}
      TF_VAR_cdn_alias: ${{ vars.CDN_ALIAS }}
      TF_VAR_create_cloudfront: ${{ vars.CREATE_CLOUDFRONT }}
      TF_VAR_default_email: ${{ vars.DEFAULT_EMAIL }}
      TF_VAR_panelapp_email: ${{ vars.PANELAPP_EMAIL }}
      TF_VAR_public_dns_zone: ${{ vars.PUBLIC_DNS_ZONE }}
      TF_VAR_public_dns_zone_name: ${{ vars.PUBLIC_DNS_ZONE_NAME }}
      TF_VAR_smtp_server: ${{ vars.SMTP_SERVER }}
      TF_VAR_terraform_infra_state_s3_bucket: ${{ vars.TERRAFORM_INFRA_STATE_S3_BUCKET }}
      TF_VAR_terraform_shared_state_s3_bucket: ${{ vars.TERRAFORM_SHARED_STATE_S3_BUCKET }}
      TF_VAR_cognito_suffix: ${{ vars.COGNITO_SUFFIX }}

    steps:
      - name: GitHub Environment Variables Action
        uses: FranzDiebold/github-env-vars-action@v2.8.0

      - name: Log inputs
        run: |
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT"
          echo "region=${{ vars.AWS_REGION }}"
          echo "env_name=${{ needs.init.outputs.env_name }}"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          unset-current-credentials: true
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_OIDC_PROVIDER_ROLE }}

      - name: Create backend.conf file
        run: |
          cat <<EOF > infra/terraform/panelapp/backend.conf
          bucket = "${{ vars.TF_STATE_BUCKET }}"
          region = "${{ vars.AWS_REGION }}"
          encrypt = true
          dynamodb_table = "${{ vars.TF_STATE_DYNAMODB_TABLE }}"
          key = "${{ vars.TF_STATE_KEY }}"
          EOF

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Initialize
        run: |
          cd infra/terraform/panelapp
          terraform init -backend-config=backend.conf

      - name: Terraform Validate
        run: |
          cd infra/terraform/panelapp
          terraform validate -no-color

      - name: Deploy web
        run: |
          export WORKING_DIR=$(pwd)
          export TF_VAR_image_tag="$CI_SHA_SHORT"
          cd infra/terraform/panelapp
          terraform apply -auto-approve -target=aws_ecs_service.panelapp_web -target=aws_ecs_task_definition.panelapp_web -target=aws_ecs_service.panelapp_worker -target=aws_ecs_task_definition.panelapp_worker
          cd $WORKING_DIR
          pip install boto3 argparse
          sleep 30
          python3 infra/run-ecs-task.py -tasks panelapp-migrate-panelapp-${{needs.init.outputs.env_name}} -panelapp
          sleep 30
          python3 infra/run-ecs-task.py -tasks panelapp-collectstatic-panelapp-${{needs.init.outputs.env_name}} -panelapp
