name: Main workflow, test and deploy to AWS

on:
  push:
    branches:
      - main
      - roo
      - develop

permissions:
  id-token: write
  contents: read

jobs:
  init:
    name: "init"
    runs-on: ubuntu-latest
    steps:
      - name: GitHub Environment Variables Action
        uses: FranzDiebold/github-env-vars-action@v2.8.0

      - id: init_env
        shell: bash
        run: |
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT"
          if [ "$CI_ACTION_REF_NAME_SLUG" == "main" ] || [ "$CI_ACTION_REF_NAME_SLUG" == "master" ] || [ "$CI_ACTION_REF_NAME_SLUG" == "roo" ]; then
            echo "env_name=prod" >> "$GITHUB_OUTPUT"
          elif [ "$CI_ACTION_REF_NAME_SLUG" == "develop" ]; then
            echo "env_name=test" >> "$GITHUB_OUTPUT"
          else
            echo "env_name=test" >> "$GITHUB_OUTPUT"
          fi
          echo "env_name=$env_name"
          echo "GITHUB_OUTPUT=$GITHUB_OUTPUT"

      - name: Log outputs
        run: |
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT"
          echo "env_name=${{ steps.init_env.outputs.env_name }}"

    outputs:
      env_name: ${{ steps.init_env.outputs.env_name }}

  tests:
    needs: init
    environment: ${{ needs.init.outputs.env_name }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [ 3.9 ]
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_DB: panelapp
          POSTGRES_USER: panelapp
          POSTGRES_PASSWORD: secret
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U panelapp -d panelapp"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    env:
      POSTGRES_DB: panelapp
      POSTGRES_USER: panelapp
      POSTGRES_PASSWORD: secret
      DATABASE_URL: postgres://panelapp:secret@localhost:5432/panelapp
      DJANGO_SETTINGS_MODULE: panelapp.settings.test
      DJANGO_LOG_LEVEL: INFO
    steps:
      - name: GitHub Environment Variables Action
        uses: FranzDiebold/github-env-vars-action@v2.8.0

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v2
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install dependencies
        run: |
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT"
          sudo apt-get install -y libpq-dev gcc python3-dev
          pip install pip==23.3.2
          pip install .[dev,tests]
          pip install pytest pytest-runner

      - name: Run tests
        run: pytest

  build:
    needs: init
    environment: ${{ needs.init.outputs.env_name }}
    runs-on: ubuntu-latest

    steps:
      - name: GitHub Environment Variables Action
        uses: FranzDiebold/github-env-vars-action@v2.8.0

      - name: Log inputs
        run: |
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT"
          echo "region=${{ vars.AWS_REGION }}"
          echo "env_name=${{ needs.init.outputs.env_name }}"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          unset-current-credentials: true
          aws-region: ${{ vars.AWS_REGION }}
#          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          role-to-assume: arn:aws:iam::487143049215:role/github-oidc-provider-aws

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to Amazon ECR
        id: build_image
        shell: bash
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          export PACKAGE_NAME=$(python setup.py --name)
          export BASE_REPO_NAME="${PACKAGE_NAME}_base_${{needs.init.outputs.env_name}}"
          export WEB_REPO_NAME="${PACKAGE_NAME}_web_${{needs.init.outputs.env_name}}"
          export WORKER_REPO_NAME="${PACKAGE_NAME}_worker_${{needs.init.outputs.env_name}}"
          echo "AWS_REGION=$AWS_REGION"
          echo "PACKAGE_NAME=$PACKAGE_NAME, BASE_REPO_NAME=$BASE_REPO_NAME, WEB_REPO_NAME=$WEB_REPO_NAME, WORKER_REPO_NAME=$WORKER_REPO_NAME"
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT"

          docker build -t "$ECR_REGISTRY/$BASE_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" --file ./docker/cloud/Dockerfile-base .
          docker tag "$ECR_REGISTRY/$BASE_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" "$ECR_REGISTRY/$BASE_REPO_NAME:$CI_SHA_SHORT"
          docker push "$ECR_REGISTRY/$BASE_REPO_NAME:$CI_ACTION_REF_NAME_SLUG"
          docker push "$ECR_REGISTRY/$BASE_REPO_NAME:$CI_SHA_SHORT"
          if [ "${{ needs.init.outputs.env_name }}" != "prod" ]; then
            echo "Tagging latest base image for non-prod environment"
            docker tag "$ECR_REGISTRY/$BASE_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" "$ECR_REGISTRY/$BASE_REPO_NAME:latest"
            docker push "$ECR_REGISTRY/$BASE_REPO_NAME:latest"
          fi

          docker build -t "$ECR_REGISTRY/$WEB_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" --build-arg "BASE_IMAGE=$ECR_REGISTRY/$BASE_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" --file ./docker/cloud/Dockerfile-web .
          docker tag "$ECR_REGISTRY/$WEB_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" "$ECR_REGISTRY/$WEB_REPO_NAME:$CI_SHA_SHORT"
          docker push "$ECR_REGISTRY/$WEB_REPO_NAME:$CI_ACTION_REF_NAME_SLUG"
          docker push "$ECR_REGISTRY/$WEB_REPO_NAME:$CI_SHA_SHORT"
          if [ "${{ needs.init.outputs.env_name }}" != "prod" ]; then
            echo "Tagging latest web image for non-prod environment"
            docker tag "$ECR_REGISTRY/$WEB_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" "$ECR_REGISTRY/$WEB_REPO_NAME:latest"
            docker push "$ECR_REGISTRY/$WEB_REPO_NAME:latest"
          fi
          echo "web_image=$ECR_REGISTRY/$WEB_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" >> "$GITHUB_OUTPUT"

          docker build -t "$ECR_REGISTRY/$WORKER_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" --build-arg "BASE_IMAGE=$ECR_REGISTRY/$BASE_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" --file ./docker/cloud/Dockerfile-worker .
          docker tag "$ECR_REGISTRY/$WORKER_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" "$ECR_REGISTRY/$WORKER_REPO_NAME:$CI_SHA_SHORT"
          docker push "$ECR_REGISTRY/$WORKER_REPO_NAME:$CI_ACTION_REF_NAME_SLUG"
          docker push "$ECR_REGISTRY/$WORKER_REPO_NAME:$CI_SHA_SHORT"
          if [ "${{ needs.init.outputs.env_name }}" != "prod" ]; then
            echo "Tagging latest worker image for non-prod environment"
            docker tag "$ECR_REGISTRY/$WORKER_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" "$ECR_REGISTRY/$WORKER_REPO_NAME:latest"
            docker push "$ECR_REGISTRY/$WORKER_REPO_NAME:latest"
          fi
          echo "worker_image=$ECR_REGISTRY/$WORKER_REPO_NAME:$CI_ACTION_REF_NAME_SLUG" >> "$GITHUB_OUTPUT"
    outputs:
      base_image: ${{ steps.build_image.outputs.base_image }}
      web_image: ${{ steps.build_image.outputs.web_image }}
      worker_image: ${{ steps.build_image.outputs.worker_image }}

  deploy:
    needs: init
    environment: ${{ needs.init.outputs.env_name }}
    runs-on: ubuntu-latest

    steps:
#      - name: Log inputs
#        run: |
#          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
#          echo "CI_SHA_SHORT=$CI_SHA_SHORT"
#          echo "region=${{ vars.AWS_REGION }}"
#          echo "env_name=${{ needs.init.outputs.env_name }}"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          unset-current-credentials: true
          aws-region: ${{ vars.AWS_REGION }}
#          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          role-to-assume: arn:aws:iam::487143049215:role/github-oidc-provider-aws

      - name: Create backend.conf file
        run: |
          cat <<EOF > infra/terraform/panelapp/backend.conf
          bucket = "${{ env.TF_STATE_BUCKET }}"
          region = "${{ env.AWS_REGION }}"
          encrypt = true
          dynamodb_table = "${{ env.TF_STATE_DYNAMODB_TABLE }}"
          key = "${{ env.TF_STATE_KEY }}"
          EOF

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Initialize
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_region: ${{ secrets.AWS_REGION }}
          TF_VAR_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          TF_VAR_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_account_id: ${{ env.ACCOUNT_ID }}
          TF_VAR_admin_email: ${{ env.ADMIN_EMAIL }}
          TF_VAR_admin_url: ${{ env.ADMIN_URL }}
          TF_VAR_cdn_alias: ${{ env.CDN_ALIAS }}
          TF_VAR_create_cloudfront: ${{ env.CREATE_CLOUDFRONT }}
          TF_VAR_default_email: ${{ env.DEFAULT_EMAIL }}
          TF_VAR_panelapp_email: ${{ env.PANELAPP_EMAIL }}
          TF_VAR_public_dns_zone: ${{ env.PUBLIC_DNS_ZONE }}
          TF_VAR_public_dns_zone_name: ${{ env.PUBLIC_DNS_ZONE_NAME }}
          TF_VAR_smtp_server: ${{ env.SMTP_SERVER }}
          TF_VAR_terraform_infra_state_s3_bucket: ${{ env.TERRAFORM_INFRA_STATE_S3_BUCKET }}
          TF_VAR_terraform_shared_state_s3_bucket: ${{ env.TERRAFORM_SHARED_STATE_S3_BUCKET }}
        run: |
          cd infra/terraform/panelapp
          terraform init -backend-config=backend.conf

      - name: Terraform Validate
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_region: ${{ secrets.AWS_REGION }}
          TF_VAR_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          TF_VAR_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_account_id: ${{ env.ACCOUNT_ID }}
          TF_VAR_admin_email: ${{ env.ADMIN_EMAIL }}
          TF_VAR_admin_url: ${{ env.ADMIN_URL }}
          TF_VAR_cdn_alias: ${{ env.CDN_ALIAS }}
          TF_VAR_create_cloudfront: ${{ env.CREATE_CLOUDFRONT }}
          TF_VAR_default_email: ${{ env.DEFAULT_EMAIL }}
          TF_VAR_panelapp_email: ${{ env.PANELAPP_EMAIL }}
          TF_VAR_public_dns_zone: ${{ env.PUBLIC_DNS_ZONE }}
          TF_VAR_public_dns_zone_name: ${{ env.PUBLIC_DNS_ZONE_NAME }}
          TF_VAR_smtp_server: ${{ env.SMTP_SERVER }}
          TF_VAR_terraform_infra_state_s3_bucket: ${{ env.TERRAFORM_INFRA_STATE_S3_BUCKET }}
          TF_VAR_terraform_shared_state_s3_bucket: ${{ env.TERRAFORM_SHARED_STATE_S3_BUCKET }}
        run: |
          cd infra/terraform/panelapp
          terraform validate -no-color

      - name: Terraform Plan
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_region: ${{ secrets.AWS_REGION }}
          TF_VAR_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          TF_VAR_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_account_id: ${{ env.ACCOUNT_ID }}
          TF_VAR_admin_email: ${{ env.ADMIN_EMAIL }}
          TF_VAR_admin_url: ${{ env.ADMIN_URL }}
          TF_VAR_cdn_alias: ${{ env.CDN_ALIAS }}
          TF_VAR_create_cloudfront: ${{ env.CREATE_CLOUDFRONT }}
          TF_VAR_default_email: ${{ env.DEFAULT_EMAIL }}
          TF_VAR_panelapp_email: ${{ env.PANELAPP_EMAIL }}
          TF_VAR_public_dns_zone: ${{ env.PUBLIC_DNS_ZONE }}
          TF_VAR_public_dns_zone_name: ${{ env.PUBLIC_DNS_ZONE_NAME }}
          TF_VAR_smtp_server: ${{ env.SMTP_SERVER }}
          TF_VAR_terraform_infra_state_s3_bucket: ${{ env.TERRAFORM_INFRA_STATE_S3_BUCKET }}
          TF_VAR_terraform_shared_state_s3_bucket: ${{ env.TERRAFORM_SHARED_STATE_S3_BUCKET }}
          TF_VAR_image_tag: test
        run: |
          cd infra/terraform/panelapp
          terraform plan -no-color -target=aws_ecs_task_definition.panelapp_web --target=aws_ecs_task_definition.panelapp_worker

#      - name: Terraform Apply
#        env:
#          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
#          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#        run: terraform apply -auto-approve
