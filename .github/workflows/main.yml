name: Main workflow, test and deploy to AWS

on:
  push:
    branches:
      - feat-genomicsengland-upstream

permissions:
  id-token: write
  contents: read

jobs:
  init:
    name: "init"
    runs-on: ubuntu-latest
    steps:
      - name: GitHub Environment Variables Action
        uses: FranzDiebold/github-env-vars-action@v2.8.0

      - id: init_env
        shell: bash
        run: |
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT" >> $GITHUB_OUTPUT
          echo "github_actions_environment=mcri-vcgs-staging" >> "$GITHUB_OUTPUT"
          echo "env_name=staging" >> "$GITHUB_OUTPUT"
          echo "GITHUB_OUTPUT=$GITHUB_OUTPUT"

      - name: Log outputs
        run: |
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT"
          echo "env_name=${{ steps.init_env.outputs.env_name }}"
          echo "github_actions_environment=${{ steps.init_env.outputs.github_actions_environment }}"

    outputs:
      env_name: ${{ steps.init_env.outputs.env_name }}
      CI_SHA_SHORT: ${{ steps.init_env.outputs.CI_SHA_SHORT }}
      github_actions_environment: ${{ steps.init_env.outputs.github_actions_environment }}

  tests:
    needs: init
    if: "!contains(github.event.head_commit.message, '[skip tests]')"
    environment: ${{ needs.init.outputs.github_actions_environment }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [ 3.11 ]
    services:
      postgres:
        image: postgres:14.7
        env:
          POSTGRES_DB: panelapp
          POSTGRES_USER: panelapp
          POSTGRES_PASSWORD: secret
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U panelapp -d panelapp"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    env:
      POSTGRES_DB: panelapp
      POSTGRES_USER: panelapp
      POSTGRES_PASSWORD: secret
      DATABASE_URL: postgres://panelapp:secret@localhost:5432/panelapp
      DJANGO_SETTINGS_MODULE: panelapp.settings.test
      DJANGO_LOG_LEVEL: INFO
      POETRY_VERSION: 1.8.5
      POETRY_PLUGIN_BUNDLE_VERSION: 1.5.0

    steps:
      - name: GitHub Environment Variables Action
        uses: FranzDiebold/github-env-vars-action@v2.8.0

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install system dependencies
        run: |
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT"
          sudo apt-get update
          sudo apt-get install -y \
            git curl libjpeg-dev zlib1g-dev gcc libpq-dev \
            libcurl4-openssl-dev libffi-dev build-essential python3-dev \
            linux-headers-generic libyaml-dev

      - name: Install Poetry & Run tests
        run: |
          python -m venv .poetry
          source .poetry/bin/activate
          pip install poetry==${{ env.POETRY_VERSION }}

      - name: Add Poetry Plugin
        run: |
          source .poetry/bin/activate && poetry lock --no-update
          poetry self add poetry-plugin-bundle==${{ env.POETRY_PLUGIN_BUNDLE_VERSION }}

      - name: Check Poetry Plugins & Lock
        run: |
          source .poetry/bin/activate && poetry lock --no-update
          poetry self show plugins
          poetry lock --no-update

      - name: Install dependencies
        run: |
          source .poetry/bin/activate && poetry lock --no-update
          poetry install --no-root --only main,test -vvv

      - name: Run tests
        run: |
          source .poetry/bin/activate && poetry lock --no-update
          poetry run pytest --cov-report term --cov-report xml

  build:
    needs: init
    environment: ${{ needs.init.outputs.github_actions_environment }}
    runs-on: ubuntu-latest

    steps:
      - name: GitHub Environment Variables Action
        uses: FranzDiebold/github-env-vars-action@v2.8.0

      - name: Log inputs
        run: |
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT"
          echo "region=${{ vars.AWS_REGION }}"
          echo "env_name=${{ needs.init.outputs.env_name }}"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          unset-current-credentials: true
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_OIDC_PROVIDER_ROLE }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Debug workspace structure
        run: |
          echo "Current directory: $(pwd)"
          echo "Contents: "
          ls -R

      - name: Build, tag, and push image to Amazon ECR
        id: build_image
        shell: bash
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          export IMAGE_TAG="$CI_SHA_SHORT"
          export BASE_REPO_NAME="panelapp_base_${{ needs.init.outputs.env_name }}"
          export WEB_REPO_NAME="panelapp_web_${{ needs.init.outputs.env_name }}"
          export WORKER_REPO_NAME="panelapp_worker_${{ needs.init.outputs.env_name }}"

          echo "Building and pushing base image..."
          docker build \
            --file docker/Dockerfile \
            --target base \
            --build-arg python_base=python:3.11.9-alpine3.19 \
            --build-arg node_base=node:20.14.0-alpine3.19 \
            --tag "$ECR_REGISTRY/$BASE_REPO_NAME:$IMAGE_TAG" .
          docker push "$ECR_REGISTRY/$BASE_REPO_NAME:$IMAGE_TAG"

          echo "Building and pushing web image..."
          docker build \
            --file docker/Dockerfile \
            --target prod \
            --build-arg BASE_IMAGE="$ECR_REGISTRY/$BASE_REPO_NAME:$IMAGE_TAG" \
            --tag "$ECR_REGISTRY/$WEB_REPO_NAME:$IMAGE_TAG" .
          docker push "$ECR_REGISTRY/$WEB_REPO_NAME:$IMAGE_TAG"

          echo "Building and pushing worker image..."
          docker build \
            --file docker/Dockerfile \
            --target prod \
            --build-arg BASE_IMAGE="$ECR_REGISTRY/$BASE_REPO_NAME:$IMAGE_TAG" \
            --tag "$ECR_REGISTRY/$WORKER_REPO_NAME:$IMAGE_TAG" .
          docker push "$ECR_REGISTRY/$WORKER_REPO_NAME:$IMAGE_TAG"

          # Optionally push 'latest' tag for non-prod
          if [ "${{ needs.init.outputs.env_name }}" != "prod" ]; then
            docker tag "$ECR_REGISTRY/$BASE_REPO_NAME:$IMAGE_TAG" "$ECR_REGISTRY/$BASE_REPO_NAME:latest"
            docker tag "$ECR_REGISTRY/$WEB_REPO_NAME:$IMAGE_TAG" "$ECR_REGISTRY/$WEB_REPO_NAME:latest"
            docker tag "$ECR_REGISTRY/$WORKER_REPO_NAME:$IMAGE_TAG" "$ECR_REGISTRY/$WORKER_REPO_NAME:latest"

            docker push "$ECR_REGISTRY/$BASE_REPO_NAME:latest"
            docker push "$ECR_REGISTRY/$WEB_REPO_NAME:latest"
            docker push "$ECR_REGISTRY/$WORKER_REPO_NAME:latest"
          fi

          echo "web_image=$ECR_REGISTRY/$WEB_REPO_NAME:$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "worker_image=$ECR_REGISTRY/$WORKER_REPO_NAME:$IMAGE_TAG" >> "$GITHUB_OUTPUT"

    outputs:
      web_image: ${{ steps.build_image.outputs.web_image }}
      worker_image: ${{ steps.build_image.outputs.worker_image }}

  deploy:
    needs: [init, tests, build]
    environment: ${{ needs.init.outputs.github_actions_environment }}
    runs-on: ubuntu-latest
    env:
      TF_VAR_env_name: ${{ needs.init.outputs.env_name }}
      TF_VAR_default_tags: '{"Stack": "panelapp", "Env": "${{ needs.init.outputs.env_name }}"}'
      TF_VAR_region: ${{ vars.AWS_REGION }}
      TF_VAR_account_id: ${{ vars.ACCOUNT_ID }}
      TF_VAR_trusted_account: ${{ vars.ACCOUNT_ID }}
      TF_VAR_admin_email: ${{ vars.ADMIN_EMAIL }}
      TF_VAR_admin_url: ${{ vars.ADMIN_URL }}
      TF_VAR_cdn_alias: ${{ vars.CDN_ALIAS }}
      TF_VAR_create_cloudfront: ${{ vars.CREATE_CLOUDFRONT }}
      TF_VAR_default_email: ${{ vars.DEFAULT_EMAIL }}
      TF_VAR_panelapp_email: ${{ vars.PANELAPP_EMAIL }}
      TF_VAR_public_dns_zone: ${{ vars.PUBLIC_DNS_ZONE }}
      TF_VAR_public_dns_zone_name: ${{ vars.PUBLIC_DNS_ZONE_NAME }}
      TF_VAR_smtp_server: ${{ vars.SMTP_SERVER }}
      TF_VAR_terraform_infra_state_s3_bucket: ${{ vars.TERRAFORM_INFRA_STATE_S3_BUCKET }}
      TF_VAR_terraform_shared_state_s3_bucket: ${{ vars.TERRAFORM_SHARED_STATE_S3_BUCKET }}
      TF_VAR_cognito_suffix: ${{ vars.COGNITO_SUFFIX }}
      TF_VAR_image_tag: ${{ needs.init.outputs.CI_SHA_SHORT }}

    steps:
      - name: GitHub Environment Variables Action
        uses: FranzDiebold/github-env-vars-action@v2.8.0

      - name: Log inputs
        run: |
          echo "CI_ACTION_REF_NAME_SLUG=$CI_ACTION_REF_NAME_SLUG"
          echo "CI_SHA_SHORT=$CI_SHA_SHORT"
          echo "region=${{ vars.AWS_REGION }}"
          echo "env_name=${{ needs.init.outputs.env_name }}"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          unset-current-credentials: true
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_OIDC_PROVIDER_ROLE }}

      - name: Create backend.conf file
        run: |
          cat <<EOF > infra/terraform/panelapp/backend.conf
          bucket = "${{ vars.TF_STATE_BUCKET }}"
          region = "${{ vars.AWS_REGION }}"
          encrypt = true
          dynamodb_table = "${{ vars.TF_STATE_DYNAMODB_TABLE }}"
          key = "${{ vars.TF_STATE_KEY }}"
          EOF

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Initialize
        run: |
          cd infra/terraform/panelapp
          terraform init -backend-config=backend.conf

      - name: Terraform Validate
        run: |
          cd infra/terraform/panelapp
          terraform validate -no-color

      - name: Terraform Plan ECS task defs
        run: |
          cd infra/terraform/panelapp
          terraform plan \
            -target=aws_ecs_task_definition.panelapp_web \
            -target=aws_ecs_service.panelapp_web \
            -target=aws_ecs_task_definition.panelapp_worker \
            -target=aws_ecs_service.panelapp_worker

      - name: Terraform Apply ECS task defs
        run: |
          cd infra/terraform/panelapp
          terraform apply -auto-approve \
            -target=aws_ecs_task_definition.panelapp_web \
            -target=aws_ecs_service.panelapp_web \
            -target=aws_ecs_task_definition.panelapp_worker \
            -target=aws_ecs_service.panelapp_worker


      - name: Run migrations & collectstatic
        run: |
          pip install boto3 argparse
          python3 infra/run-ecs-task.py -tasks panelapp-migrate-panelapp-${{ needs.init.outputs.env_name }} -panelapp
          sleep 30
          python3 infra/run-ecs-task.py -tasks panelapp-collectstatic-panelapp-${{ needs.init.outputs.env_name }} -panelapp
