include:
  - local: ".gitlab-ci/envs.yml"
  - component: $CI_SERVER_FQDN/genomicsengland/secure-sdlc/cicd-components/secrets-detection/secretsdetection@1

variables:
  DOCKER_PYTHON: python:3.11.9-alpine3.19
  DOCKER_NODE: node:20.14.0-alpine3.19
  DOCKER_POSTGRES: docker.artifactory.aws.gel.ac/library/postgres:14.7
  DOCKER_PLAYWRIGHT: mcr.microsoft.com/playwright:v1.47.0-jammy
  DOCKER_IN_DOCKER: docker:24.0.1-dind
  DOCKER_DRIVER: overlay2
  DOCKER_HOST: tcp://docker:2376/
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  DOCKER_TLS_VERIFY: 1
  FF_GITLAB_REGISTRY_HELPER_IMAGE: 1
  PANELAPP_TF_DIR: "panelapp-infra/terraform/panelapp/"
  POETRY_VERSION: "1.8.2"
  POETRY_VENV: /tmp/poetry
  AWS_REGION: eu-west-2
  AWS_DEFAULT_REGION: eu-west-2
  AWS_ACCOUNT_ID: "577192787797"
  AWS_ASSUME_ROLE: "arn:aws:iam::${AWS_ACCOUNT_ID}:role/CIDeploypanelapp"
  ECR_ACCOUNT_ID: 577192787797
  ECR_REGISTRY: "${ECR_ACCOUNT_ID}.dkr.ecr.eu-west-2.amazonaws.com"
  ECR_ASSUME_ROLE: "arn:aws:iam::${ECR_ACCOUNT_ID}:role/CIDeploypanelapp"
  ECR_REPOSITORY: panelapp
  TAGGER_REGISTRY: $ECR_ACCOUNT_ID
  TAGGER_REPOSITORY: $ECR_REPOSITORY
  TAGGER_ENVIRONMENTS: "build,dev,test,e2e,uat,prod"
  #  TAGGER_DEBUG: 'yes'
  CI_DEBUG_TRACE: "false"
  #  TF_LOG: DEBUG
  E2E_TEST_IMAGE_TAG: "$CI_REGISTRY_IMAGE/e2e-test:$CI_COMMIT_SHORT_SHA"
  APP_VERSION: "0.0.0"
  env_name: dev

stages:
  - entrygate
  - test_build
  - test
  - image_build
  - tag

services:
  - name: $DOCKER_IN_DOCKER
    alias: docker
    command:
      - "--registry-mirror"
      - "https://docker.artifactory.aws.gel.ac"

default:
  tags:
    - pool_name:panelapp_docker

.tests:
  image: $DOCKER_PYTHON
  stage: test

.tag:
  image: $DOCKER_IN_DOCKER
  before_script:
    - apk add aws-cli jq py3-boto3
    - source scripts/assume_role.sh
  variables:
    AWS_ASSUME_ROLE: $ECR_ASSUME_ROLE

debug:
  stage: test
  needs: []
  script:
    - env -u CI_JOB_JWT_V1 -u CI_JOB_JWT_V2 -u gel_gitlab_runner_key | sort

# Code checks
## run unit and integration tests
code_test:
  extends: .tests
  needs: []
  coverage: /^TOTAL.+?(\d+\%)$/
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
      junit: report.xml
  services:
    - name: $DOCKER_POSTGRES
      alias: db-postgres
  variables:
    POSTGRES_DB: panelapp
    POSTGRES_USER: panelapp
    POSTGRES_PASSWORD: secret
    DATABASE_URL: postgres://panelapp:secret@db-postgres:5432/panelapp
    DJANGO_SETTINGS_MODULE: panelapp.settings.test
    DJANGO_LOG_LEVEL: INFO
  before_script:
    - apk add --no-cache postgresql-libs git curl jpeg-dev zlib-dev gcc musl-dev curl-dev postgresql-dev build-base linux-headers libffi-dev
    - python3 -m venv "$POETRY_VENV"
    - $POETRY_VENV/bin/pip install -U pip setuptools
    - $POETRY_VENV/bin/pip install poetry=="$POETRY_VERSION"
    - $POETRY_VENV/bin/poetry self add poetry-plugin-bundle
    - $POETRY_VENV/bin/poetry bundle venv --only main,test ./.venv
    - source .venv/bin/activate
  script:
    - pytest --cov-report term --cov-report xml --junitxml=report.xml

# Build docker image for end-to-end testing purposes
e2e_test_image_build:
  image: $DOCKER_IN_DOCKER
  stage: test_build
  needs: []
  before_script:
    - apk add aws-cli jq py3-boto3
    - source scripts/assume_role.sh
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_JOB_TOKEN $CI_REGISTRY
    - docker build -f ./docker/Dockerfile -t "$E2E_TEST_IMAGE_TAG" --target test --build-arg node_base="${DOCKER_NODE}" --build-arg python_base="${DOCKER_PYTHON}" .
    - docker push "$E2E_TEST_IMAGE_TAG"

.e2e_test:
  image: $DOCKER_PLAYWRIGHT
  stage: test
  dependencies:
    - e2e_test_image_build
  artifacts:
    paths:
      - test-results/
      - playwright-report/
    when: always
  services:
    - name: $DOCKER_POSTGRES
      alias: db-postgres
      variables:
        POSTGRES_DB: panelapp
        POSTGRES_USER: panelapp
        POSTGRES_PASSWORD: secret
    - name: $E2E_TEST_IMAGE_TAG
      alias: web
      variables:
        PYTHONUNBUFFERED: "1"
        DJANGO_LOG_LEVEL: DEBUG
        DJANGO_SETTINGS_MODULE: panelapp.settings.test
        DATABASE_URL: postgres://panelapp:secret@db-postgres:5432/panelapp
        ALLOWED_HOSTS: web
      command:
        - /bin/sh
        - "-c"
        - "manage migrate && manage loaddata /app/data.json && manage runserver 0.0.0.0:8000"
  variables:
    # Allows inter-service communication: https://stackoverflow.com/questions/48041101/gitlab-ci-cross-service-communication
    FF_NETWORK_PER_BUILD: 1
    BASE_URL: http://web:8000
  before_script:
    - npm ci

e2e_test_functional:
  extends: .e2e_test
  script:
    - npx playwright test tests/functional/

e2e_test_bdd:
  extends: .e2e_test
  script:
    - npx bddgen -c playwright-bdd.config.ts
    - npx playwright test -c playwright-bdd.config.ts

e2e_test_visual:
  extends: .e2e_test
  script:
    - npx playwright test tests/visual/

test_component:
  extends: .e2e_test
  script:
    - npm run test-ct

## Linting, formatting, etc
import_sorting:
  extends: .tests
  needs: []
  before_script:
    - python3 -m venv "$POETRY_VENV"
    - $POETRY_VENV/bin/pip install -U pip setuptools
    - $POETRY_VENV/bin/pip install poetry=="$POETRY_VERSION"
    - $POETRY_VENV/bin/poetry self add poetry-plugin-bundle
    - $POETRY_VENV/bin/poetry bundle venv --only dev ./.venv
    - source .venv/bin/activate
  script:
    - isort . -c

formatter:
  extends: .tests
  needs: []
  before_script:
    - python3 -m venv "$POETRY_VENV"
    - $POETRY_VENV/bin/pip install -U pip setuptools
    - $POETRY_VENV/bin/pip install poetry=="$POETRY_VERSION"
    - $POETRY_VENV/bin/poetry self add poetry-plugin-bundle
    - $POETRY_VENV/bin/poetry bundle venv --only dev ./.venv
    - source .venv/bin/activate
  script:
    - black . --check

trivy:
  stage: test
  needs: []
  image:
    name: aquasec/trivy:0.42.1
    entrypoint: [""]
  script:
    - trivy fs --exit-code 0 --cache-dir .trivycache/ --severity MEDIUM,HIGH,CRITICAL --ignore-unfixed --format template --template "@/contrib/junit.tpl" -o trivy.junit.xml .
    - trivy fs --exit-code 1 --cache-dir .trivycache/ --severity CRITICAL --ignore-unfixed --no-progress .
    - if [[ -s .trivyignore ]]; then echo ".trivyignore is not empty" ; cat .trivyignore ; exit 2 ; fi
  allow_failure:
    exit_codes:
      - 2 # warn when .trivyignore exists and is not empty
  rules:
    - if: $TEST
      allow_failure: true
      when: never
  artifacts:
    when: always
    reports:
      junit: "trivy.junit.xml"
    paths:
      - "trivy.junit.xml"

# Build docker image
image_build:
  image: $DOCKER_IN_DOCKER
  stage: image_build
  before_script:
    - apk add aws-cli jq py3-boto3
    - source scripts/assume_role.sh
  script:
    - aws ecr get-login-password --region eu-west-2 | docker login --username AWS --password-stdin "$ECR_REGISTRY"
    - if scripts/tagger validate-version "$APP_VERSION"; then sed -i -e "s/^version =.*/version = \"${APP_VERSION}\"/" ./pyproject.toml; fi
    - docker build -f ./docker/Dockerfile -t "$ECR_REGISTRY/$ECR_REPOSITORY:$BUILD_TAG" --target prod --build-arg node_base="${DOCKER_NODE}" --build-arg python_base="${DOCKER_PYTHON}" .
    - docker push "$ECR_REGISTRY/$ECR_REPOSITORY:$BUILD_TAG"
    - scripts/tagger add-env-tags --env=build --add-latest=1 "$BUILD_TAG"
  variables:
    AWS_ASSUME_ROLE: $ECR_ASSUME_ROLE
    BUILD_TAG: "ci-$CI_PIPELINE_ID"
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"

scan:
  stage: image_build
  needs:
    - image_build
  environment:
    name: $env_name
  image: $DOCKER_IN_DOCKER
  before_script:
    - apk add aws-cli jq py3-boto3
    - |
      export $(printf "AWS_ACCESS_KEY_ID=%s AWS_SECRET_ACCESS_KEY=%s AWS_SESSION_TOKEN=%s" \
        $(aws sts assume-role \
          --role-arn "${AWS_ASSUME_ROLE}" \
          --role-session-name "gitlab-ci-${CI_PROJECT_NAME}-${CI_PIPELINE_IID}" \
          --query "Credentials.[AccessKeyId,SecretAccessKey,SessionToken]" \
          --output text
        )
      )
  script:
    - aws ecr describe-image-scan-findings --repository-name "$ECR_REPOSITORY" --image-id imageTag="$BUILD_TAG" | tee "inspector_findings_$BUILD_TAG.json"
    - count_findings () { jq ".imageScanFindings.findingSeverityCounts.$1 // 0" "inspector_findings_$BUILD_TAG.json"; }
    - |
      set -e
      if [ "$(count_findings CRITICAL)" -gt 0 ]; then
        echo -e "\e[91mThe image "$ECR_REPOSITORY:$BUILD_TAG" has $(count_findings CRITICAL) CRITICAL findings.\e[0m"
        exit 101
      elif [ "$(count_findings HIGH)" -gt 0 ]; then
        echo -e "\e[93mThe image "$ECR_REPOSITORY:$BUILD_TAG" has $(count_findings HIGH) HIGH findings.\e[0m"
        exit 102
      else
        echo -e "\e[92mAll good!\e[0m"
      fi
  variables:
    AWS_ASSUME_ROLE: $ECR_ASSUME_ROLE
    BUILD_TAG: "ci-$CI_PIPELINE_ID"
  allow_failure:
    exit_codes:
      - 101
      - 102
  artifacts:
    paths:
      - inspector_findings_$BUILD_TAG.json
    when: on_failure

add_tags:
  stage: tag
  extends: .tag
  script:
    - '(scripts/tagger validate-version "$APP_VERSION" && ! scripts/tagger tag-exists "$APP_VERSION") || scripts/tagger freestyle-tag "$APP_VERSION"'
    - scripts/tagger add-tag "$BUILD_TAG" "$APP_VERSION"
    - scripts/tagger --verbose list-tags
  variables:
    BUILD_TAG: "ci-$CI_PIPELINE_ID"
  rules:
    - if: $CI_PIPELINE_SOURCE == "push" && $APP_VERSION != "0.0.0"
