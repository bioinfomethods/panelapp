include:
  - local: '.gitlab-ci/envs.yml'
  - template: Code-Quality.gitlab-ci.yml

variables:
  PANELAPP_TF_DIR : "panelapp-infra/terraform/panelapp/"
  AWS_REGION: eu-west-2
  CI_DEBUG_TRACE: "false"
  AWS_ASSUME_ROLE_TERRAFORM: "arn:aws:iam::${AWS_ACCOUNT_ID}:role/CIDeploypanelapp"
  env_name:
    description: "Environment to target"
    value: "dev"
  version:
    description: "Version to deploy"
    value: ""

stages:
  - test
  - image_build
  - plan
  - apply

services:
  - name: docker:20.10.7-dind
    alias: docker
    command:
      - "--registry-mirror"
      - "http://dockerhubcache.shared-services.aws.gel.ac:5002"

# Common deploy functionality
.deploy_default:
  image:
    name: hashicorp/terraform:1.3.9
    entrypoint: ["/bin/sh", "-c"]
  tags:
    - pool_name:panelapp_docker
  before_script:
    - apk --no-cache add --update python3 curl jq aws-cli
    - python3 -m venv .venv
    - source .venv/bin/activate
    - pip install boto3==1.21.1
    - aws sts get-caller-identity
    - creds_json=$(aws sts assume-role --role-arn ${AWS_ASSUME_ROLE_TERRAFORM} --role-session-name runner-promotion )
    - export AWS_ACCESS_KEY_ID=$(echo "$creds_json" | jq .Credentials.AccessKeyId |tr -d '"')
    - export AWS_SECRET_ACCESS_KEY=$(echo "$creds_json" | jq .Credentials.SecretAccessKey| tr -d '"')
    - export AWS_SESSION_TOKEN=$(echo "$creds_json" | jq .Credentials.SessionToken|tr -d '"')
    - export AWS_DEFAULT_REGION=$default_region
   
.tests:
  stage: test
  rules:
    - if: $CI_MERGE_REQUEST_ID

code_quality:
  extends: .tests
  artifacts:
    paths: [gl-code-quality-report.json]
  rules:
    - if: "$CODE_QUALITY_DISABLED"
      when: never
    - if: $CI_MERGE_REQUEST_ID

# Code checks
## run unit and integration tests
code_test:
  image: python:3.8-alpine3.12
  extends: .tests
  coverage: /^TOTAL.+?(\d+\%)$/
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
  services:
    - name: postgres:9.6.9
      alias: db-postgres
  variables:
    POSTGRES_DB: panelapp
    POSTGRES_USER: panelapp
    POSTGRES_PASSWORD: secret
    DATABASE_URL: postgres://panelapp:secret@db-postgres:5432/panelapp
    DJANGO_SETTINGS_MODULE: panelapp.settings.test
    DJANGO_LOG_LEVEL: INFO
  before_script:
    - apk add --no-cache postgresql-libs git curl jpeg-dev zlib-dev gcc musl-dev curl-dev postgresql-dev build-base linux-headers libffi-dev
    - python -m venv .venv
    - source .venv/bin/activate
    - pip install .[tests]
    - pip install pytest-runner
  script:
    - pytest --cov-report term --cov-report xml
  rules:
    - if: $NIGHTLY_TEST == "true" && $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

## Linging, formatting, etc
import_sorting:
  image: python:3.8
  extends: .tests
  before_script:
    - python -m venv .venv
    - source .venv/bin/activate
    - pip install isort==5.0.5
  script:
    - isort . -c

formatter:
  image: python:3.8
  extends: .tests
  before_script:
    - python -m venv .venv
    - source .venv/bin/activate
    - pip install black==22.3.0
  script:
    - black . --check

# Build docker image
image_build:
  image: docker:stable
  tags:
    - "pool_name:panelapp_docker"
  services:
    - name: docker:19.03.5-dind
      command:
        [
          "--registry-mirror",
          "http://dockerhubcache.shared-services.aws.gel.ac:5002",
        ]
  stage: image_build
  before_script:
    - apk add aws-cli
    - apk add jq
    - source scripts/assume_role.sh
  script:
    # installing py-setuptools to extract the name and version
    - apk -U add py-setuptools make
    - echo $CI_COMMIT_TAG > ./VERSION
    - export PACKAGE_NAME=$(python3 setup.py --name)
    - export PACKAGE_VERSION=$(python3 setup.py --version)
    # Check whether the Package Version matches with the TAG version
    #- (if [ PACKAGE_VERSION = $CI_COMMIT_TAG ]; then /bin/true; echo "TAG and file Version matches"; else echo "Error!! TAG NAME AND Version file did not Match";/bin/false; fi)
    # Build the docker image
    - docker build -t ${PACKAGE_NAME}-base --file ./docker/cloud/Dockerfile-base .
    - docker build -t ${PACKAGE_NAME}-web --file ./docker/cloud/Dockerfile-web .
    - docker build -t ${PACKAGE_NAME}-worker --file ./docker/cloud/Dockerfile-worker .
    # # login into dockerHub to push the images
    # - docker login -u $DOCKERHUB_USER -p $DOCKERHUB_PASS
    # # Tag the images with Version and push them to DockerHub
    # - docker tag ${PACKAGE_NAME}-web $DOCKERHUB_ORG/${PACKAGE_NAME}-web:${PACKAGE_VERSION}
    # - docker tag ${PACKAGE_NAME}-worker $DOCKERHUB_ORG/${PACKAGE_NAME}-worker:${PACKAGE_VERSION}
    # - docker tag ${PACKAGE_NAME}-base $DOCKERHUB_ORG/${PACKAGE_NAME}-base:${PACKAGE_VERSION}
    # - docker push $DOCKERHUB_ORG/${PACKAGE_NAME}-web:${PACKAGE_VERSION}
    # - docker push $DOCKERHUB_ORG/${PACKAGE_NAME}-worker:${PACKAGE_VERSION}
    # - docker push $DOCKERHUB_ORG/${PACKAGE_NAME}-base:${PACKAGE_VERSION}
    # # Tag images as latest and push them to DockerHub
    # - docker tag ${PACKAGE_NAME}-web $DOCKERHUB_ORG/${PACKAGE_NAME}-web:latest
    # - docker tag ${PACKAGE_NAME}-worker $DOCKERHUB_ORG/${PACKAGE_NAME}-worker:latest
    # - docker tag ${PACKAGE_NAME}-base $DOCKERHUB_ORG/${PACKAGE_NAME}-base:latest
    # - docker push $DOCKERHUB_ORG/${PACKAGE_NAME}-web:latest
    # - docker push $DOCKERHUB_ORG/${PACKAGE_NAME}-worker:latest
    # - docker push $DOCKERHUB_ORG/${PACKAGE_NAME}-base:latest
    # login into ECR to push the images
    - aws ecr get-login-password --region eu-west-2 | docker login --username AWS --password-stdin "${ECR_REPOSITORY}"
    # Tag the images with Version and push them to ECR
    - docker tag ${PACKAGE_NAME}-web ${ECR_REPOSITORY}/${PACKAGE_NAME}-web:${PACKAGE_VERSION}
    - docker tag ${PACKAGE_NAME}-worker ${ECR_REPOSITORY}/${PACKAGE_NAME}-worker:${PACKAGE_VERSION}
    - docker tag ${PACKAGE_NAME}-base ${ECR_REPOSITORY}/${PACKAGE_NAME}-base:${PACKAGE_VERSION}
    - docker push ${ECR_REPOSITORY}/${PACKAGE_NAME}-web:${PACKAGE_VERSION}
    - docker push ${ECR_REPOSITORY}/${PACKAGE_NAME}-worker:${PACKAGE_VERSION}
    - docker push ${ECR_REPOSITORY}/${PACKAGE_NAME}-base:${PACKAGE_VERSION}
    # Tag images as latest and push them to ECR
    - docker tag ${PACKAGE_NAME}-web ${ECR_REPOSITORY}/${PACKAGE_NAME}-web:latest
    - docker tag ${PACKAGE_NAME}-worker ${ECR_REPOSITORY}/${PACKAGE_NAME}-worker:latest
    - docker tag ${PACKAGE_NAME}-base ${ECR_REPOSITORY}/${PACKAGE_NAME}-base:latest
    - docker push ${ECR_REPOSITORY}/${PACKAGE_NAME}-web:latest
    - docker push ${ECR_REPOSITORY}/${PACKAGE_NAME}-worker:latest
    - docker push ${ECR_REPOSITORY}/${PACKAGE_NAME}-base:latest
  rules:
    - if: $CI_COMMIT_TAG =~ /\d+\.\d+\.\d+(\w+)?$/

# Deploy all the things
plan:
  stage: plan
  extends:
    - .deploy_default
  environment:
    name: $env_name
  dependencies:
    - image_build
  script:
    - git clone --single-branch --branch main https://$TF_CODE_REPO_USER:$TF_CODE_REPO_TOKEN@gitlab.com/genomicsengland/panelapp/panelapp-infra.git
    - git clone --single-branch --branch main https://$CONFIG_DEPLOY_TOKEN_USERNAME:$TF_CONFIG_REPO_TOKEN@gitlab.com/genomicsengland/panelapp/panelapp-config-new.git
    - export WORKING_DIR=$(pwd)
    - cd $PANELAPP_TF_DIR 
    - terraform init -backend-config "$WORKING_DIR/panelapp-config-new/$env_name/panelapp-backend.conf" 
    - terraform plan -var-file="$WORKING_DIR/panelapp-config-new/$env_name/terraform.tfvars" -out=plan.tfplan -var image_tag=$version  
  rules:
    - if: $version =~ /^\d+\.\d+\.\d+(\w+)?$/
  artifacts:
    paths:
      - $PANELAPP_TF_DIR/.terraform*
      - $PANELAPP_TF_DIR/plan.*
      - $PANELAPP_TF_DIR/*.zip
      - $PANELAPP_TF_DIR/templates/*
      - panelapp-infra/*.py

apply:
  stage: apply
  extends:
    - .deploy_default
  environment:
    name: $env_name
  dependencies:
    - plan
  script:
    - export WORKING_DIR=$(pwd)
    - cd $PANELAPP_TF_DIR 
    - terraform apply plan.tfplan
    - sleep 30
    - python3 $WORKING_DIR/panelapp-infra/run-ecs-task.py -tasks panelapp-migrate-panelapp-$env_name -panelapp
    - sleep 30
    - python3 $WORKING_DIR/panelapp-infra/run-ecs-task.py -tasks panelapp-collectstatic-panelapp-$env_name -panelapp
  rules:
    - if: $version =~ /^\d+\.\d+\.\d+(\w+)?$/
      when: manual
