#!/usr/bin/env python3
"""\
Tool to manage Docker image tags for ECR cleanup.

# Requirements
    * Python 3.8+
    * boto3

Typical workflows:

Building:

    Depending on whether the application version is hardcoded at (a) commit time, (b) build time, or (c) deployment.


    (a)

    build_tag="git-$CI_COMMIT_SHORT_SHA"
    aws ecr get-login-password --region eu-west-2 | docker login --username AWS --password-stdin "$REGISTRY"
    docker build -t "$REGISTRY/$REPOSITORY:$build_tag" .
    docker push "$REGISTRY/$REPOSITORY:$build_tag"
    scripts/tagger add-env-tags --env=build --add-latest "$build_tag"
    scripts/tagger add-tag "$build_tag" "$VERSION"

    (b)

    build_tag="ci-$CI_JOB_ID"
    # rest same as (a)

    (c)

    build_tag="git-$CI_COMMIT_SHORT_SHA"
    # lazy building
    if ! scripts/tagger --repository="$REPOSITORY" tag-exists "$build_tag"; then
        aws ecr get-login-password --region eu-west-2 | docker login --username AWS --password-stdin "$REGISTRY"
        docker build -t "$REGISTRY/$REPOSITORY:$build_tag" .
        docker push "$REGISTRY/$REPOSITORY:$build_tag"
        scripts/tagger add-env-tags --env=build --add-latest "$build_tag"
    fi
    scripts/tagger add-tag "$build_tag" "$VERSION"



Deploy to environment

    # plan
    scripts/tagger validate-version-tag $VERSION
    terraform plan -var version=$version -out=plan.tfplan
    # apply
    terraform apply plan.tfplan
    scripts/tagger add-env-tags --env=$env --add-latest=3 "$VERSION"

"""

import argparse
import contextlib
import dataclasses
import datetime
import enum
import functools
import os
import re
import sys
from operator import itemgetter
from typing import (
    List,
    Match,
    Optional,
    cast,
)

import boto3

ENVIRONMENTS = (
    os.getenv("TAGGER_ENVIRONMENTS", "build,dev,test,e2e,uat,prod")
    .strip()
    .lower()
    .split(",")
)
RE_ENV = re.compile(r"^[a-z0-9_]+$")
if not all(RE_ENV.match(x) for x in ENVIRONMENTS):
    sys.exit(os.EX_CONFIG)


class Commands(str, enum.Enum):
    GET_TAGS = "get-tags"
    LIST_TAGS = "list-tags"
    CHECK_TAG = "tag-exists"
    ADD_ENV_TAG = "add-env-tags"
    ADD_TAG = "add-tag"
    VALIDATE_VERSION = "validate-version"
    FREESTYLE_TAG = "freestyle-tag"
    SELF_TEST = "self-tests"


class MutabilityOpts(str, enum.Enum):
    YES = "yes"
    NO = "no"
    AUTO = "auto"


@dataclasses.dataclass
class Image:
    pushed_at: datetime.datetime
    tags: List[str]

    @property
    def id_tags(self):
        return sorted([x for x in self.tags if Tagger.is_id_tag(x)])

    @property
    def versions(self):
        return sorted(x for x in self.tags if Tagger.is_version_tag(x))

    @property
    def env_tags(self):
        return sorted(x for x in self.tags if Tagger.is_env_tag(x))

    @property
    def latest_tags(self):
        return sorted(x for x in self.tags if Tagger.is_rotating_tag(x))

    @property
    def other_tags(self):
        return sorted(x for x in self.tags if not Tagger.is_special_tag(x))


@functools.total_ordering
class SemVers:
    def __init__(self, version: str):
        self.version = version
        self.match = cast(Match, Tagger.RE_VERSION.search(version))
        if not self.match:
            raise ValueError("not a simplified semantic version")

    @property
    def major(self) -> int:
        """
        >>> SemVers('1.2.3').major
        1
        """
        return int(self.match.group(1))

    @property
    def minor(self) -> int:
        """
        >>> SemVers('1.2.3').minor
        2
        """
        return int(self.match.group(2))

    @property
    def patch(self) -> int:
        """
        >>> SemVers('1.2.3').patch
        3
        """
        return int(self.match.group(3))

    @property
    def pre_release_type(self) -> Optional[str]:
        """
        >>> SemVers('1.2.3-alpha.4').pre_release_type
        'alpha'
        >>> SemVers('1.2.3').pre_release_type
        """
        return self.match.group(5)

    @property
    def pre_release_version(self) -> Optional[int]:
        """
        >>> SemVers('1.2.3-alpha.4').pre_release_version
        4
        >>> SemVers('1.2.3').pre_release_version
        """
        return int(group) if (group := self.match.group(6)) is not None else None

    def __eq__(self, other):
        """
        Version equality

        >>> SemVers('1.2.3') == SemVers('1.2.3')
        True
        >>> SemVers('1.2.3') == "1.2.3"
        True
        """
        return self.version == other

    def __lt__(self, other):
        """
        Semantic ordering of versions

        >>> SemVers('1.3.2') <= SemVers('1.2.3')
        False
        >>> SemVers('1.2.3-rc.1') < SemVers('1.2.3')
        True
        >>> SemVers('1.2.3-alpha.4') < SemVers('1.2.3-beta.2')
        True
        """
        if not isinstance(other, SemVers):
            other = SemVers(other)
            raise NotImplementedError(
                f"can not compare with object of type: {type(other)}"
            )
        max_type = "zzzz"
        max_version = 9999
        left = (
            self.major,
            self.minor,
            self.patch,
            self.pre_release_type or max_type,
            self.pre_release_version or max_version,
        )
        right = (
            other.major,
            other.minor,
            other.patch,
            other.pre_release_type or max_type,
            other.pre_release_version or max_version,
        )
        return left < right

    def __str__(self):
        return self.version

    def __repr__(self):
        return f"SemVers({self.version!r})"


class Tagger:
    _client = None
    args: argparse.Namespace

    # Max number of rotating tags (per type):
    MAX_ROTATING_TAGS = 10
    # Time format used for env tags, like "prod-20230130-173000":
    TIME_FORMAT = "%Y%m%d-%H%M%S"
    # Tag used to identify commits, like "git-abc1234f:
    RE_ID_TAG = re.compile(
        r"""^(
            git-[a-f0-9]{8} |
            ci-[0-9]+
        )$""",
        re.VERBOSE,
    )
    # Simplified semantic versioning tag:
    RE_VERSION = re.compile(
        r"""^
        (0|[1-9][0-9]*) \. (0|[1-9][0-9]*) \. (0|[1-9][0-9]*)
        ( - (alpha|beta|rc) \. ([1-9][0-9]*) )?
        $""",
        re.VERBOSE,
    )
    # Environment specific tags (first deployment):
    RE_ENV = re.compile(
        f"""^
        ( {'|'.join(ENVIRONMENTS)} ) - [0-9]{{8}} - [0-9]{{6}}
        $""",
        re.VERBOSE,
    )
    # Rotating tags:
    RE_ROTATING = re.compile(
        f"""^
        latest- ({'|'.join(ENVIRONMENTS)})
        ( - [0-9]+ )?
        $""",
        re.VERBOSE,
    )
    # Protected superset of git, ci, env, version, and rotating tags; everything else can be freely used
    RE_RESTRICTED = re.compile(
        f"""^
        (
            git- |
            ci- |
            ( {'|'.join(ENVIRONMENTS)} ) - |
            latest |
            [0-9]
        )
        """,
        re.VERBOSE,
    )

    def __init__(self, argv: List[str]):
        self.args = self.parse_args(argv)
        self.debug(self.args)

    @property
    def client(self):
        if self._client is None:
            if self.args.assume_role:
                client = boto3.client("sts")
                response = client.assume_role(
                    RoleArn=self.args.assume_role,
                    RoleSessionName="tagger-session",
                )
                self.debug(f'assume_role: {response["AssumedRoleUser"]["Arn"]}')
                new_session = boto3.Session(
                    aws_access_key_id=response["Credentials"]["AccessKeyId"],
                    aws_secret_access_key=response["Credentials"]["SecretAccessKey"],
                    aws_session_token=response["Credentials"]["SessionToken"],
                )
                self._client = new_session.client("ecr")
            else:
                self._client = boto3.client("ecr")
        return self._client

    def parse_args(self, argv: List[str]) -> argparse.Namespace:
        def timestamp(t: str) -> str:
            return datetime.datetime.strptime(t, self.TIME_FORMAT).strftime(
                self.TIME_FORMAT
            )

        parser = argparse.ArgumentParser(
            description=__doc__.splitlines()[0],
            epilog="Help for specific command: tagger COMMAND --help",
        )
        parser.add_argument(
            "--repository", help="name of the repository to operate on", required=False
        )
        parser.add_argument(
            "--registry", help="id of the registry to operate on", required=False
        )
        parser.add_argument("--assume-role", metavar="ROLE_ARN", help="assume role")
        parser.add_argument("--debug", action="store_true", help="add debug output")
        parser.add_argument("--verbose", action="store_true", help="verbose output")
        subparsers = parser.add_subparsers(
            metavar="command",
            dest="command",
            required=True,
            help="help with: tagger command --help",
        )

        parser_gt = subparsers.add_parser(
            Commands.GET_TAGS.value, help="get all tags of an image"
        )
        parser_gt.add_argument("image_tag", help="tag of image to look up")
        parser_gt.set_defaults(func=self.cmd_get_tags)

        parser_ct = subparsers.add_parser(
            Commands.CHECK_TAG.value,
            help="check whether a tag exists (return code = 0) or not (return code = 1)",
        )
        parser_ct.add_argument("image_tag", help="tag of image to look up")
        parser_ct.set_defaults(func=self.cmd_tag_exists)

        parser_rt = subparsers.add_parser(
            Commands.FREESTYLE_TAG.value,
            help="check whether a tag can be used freely (return code = 0) "
            "or is restricted (return code = 1)",
        )
        parser_rt.add_argument("image_tag", help="tag of image to look up")
        parser_rt.set_defaults(func=self.cmd_tag_is_freestyle)

        parser_aet = subparsers.add_parser(
            Commands.ADD_ENV_TAG.value, help="add an environment tag"
        )
        parser_aet.add_argument(
            "image_tag", help="tag of image to add the environment tag"
        )
        parser_aet.add_argument(
            "--env",
            default=ENVIRONMENTS[0],
            choices=ENVIRONMENTS,
            help='environment to use (default: "%(default)s")',
        )
        parser_aet.add_argument(
            "--add-latest",
            metavar="NUMBER",
            nargs="?",
            type=int,
            default=0,
            const=1,
            choices=range(self.MAX_ROTATING_TAGS + 1),
            help='add a "latest-<env>-0" tag and shift existing "latest" tags, i.e. '
            '"latest-<env>-0" becomes "latest-<env>-1" and so on up to NUMBER tags in total. '
            'If NUMBER is 1 (or omitted), add "latest-<env>" tag. '
            'The default is to not add any "latest" tags',
        )
        parser_aet.add_argument(
            "--timestamp",
            metavar="TIMESTAMP",
            type=timestamp,
            default=datetime.datetime.utcnow().strftime("%Y%m%d-%H%M%S"),
            help='use TIMESTAMP instead of "now"; for retro-fitting tags to an existing repository;'
            ' must be in the format "YYYYmmdd-HHMMSS"',
        )
        parser_aet.set_defaults(func=self.cmd_add_env_tag)

        parser_vvt = subparsers.add_parser(
            Commands.VALIDATE_VERSION.value, help="validate a version"
        )
        parser_vvt.add_argument("version", help="version to validate")
        parser_vvt.add_argument(
            "--no-alpha", action="store_true", help="fail if version is alpha"
        )
        parser_vvt.add_argument(
            "--no-beta", action="store_true", help="fail if version is beta"
        )
        parser_vvt.add_argument(
            "--no-rc", action="store_true", help="fail if version is rc"
        )
        parser_vvt.set_defaults(func=self.cmd_validate_version)

        parser_at = subparsers.add_parser(Commands.ADD_TAG.value, help="add an new tag")
        parser_at.add_argument("image_tag", help="tag of image to add the new tag")
        parser_at.add_argument("new_tag", help="tag to add")
        parser_at.add_argument(
            "--mutable",
            default="auto",
            choices=[o.value for o in MutabilityOpts],
            help="treat new_tag as mutable; version tags can not be mutable; default: %(default)s",
        )
        parser_at.set_defaults(func=self.cmd_add_tag)

        parser_lt = subparsers.add_parser(
            Commands.LIST_TAGS.value, help="list all tags in a table"
        )
        parser_lt.set_defaults(func=self.cmd_list_tags)

        parser_st = subparsers.add_parser(
            Commands.SELF_TEST.value, help="run the self test"
        )
        parser_st.add_argument(
            "--verbose", action="store_true", default=False, help="verbose test output"
        )
        parser_st.set_defaults(func=self.cmd_selftest)

        args = parser.parse_args(args=argv)

        if not args.registry:
            args.registry = os.environ.get("TAGGER_REGISTRY")
        if not args.repository:
            args.repository = os.environ.get("TAGGER_REPOSITORY")
        if not args.assume_role:
            args.assume_role = os.environ.get("TAGGER_ASSUME_ROLE")
        if not args.debug:
            args.debug = bool(os.environ.get("TAGGER_DEBUG"))

        return args

    @staticmethod
    def timestamp() -> str:
        return datetime.datetime.utcnow().strftime("%Y%m%d-%H%M%S")

    def debug(self, message):
        if self.args.debug:
            print(message, file=sys.stderr, flush=True)

    @classmethod
    def is_version_tag(cls, tag: str) -> bool:
        """
        Returns whether tag is a simplified semantic versioning tag.

        >>> Tagger.is_version_tag('2.0.3-alpha.4')
        True
        >>> Tagger.is_version_tag('2.0.3-a4')
        False
        >>> Tagger.is_version_tag('02.00.01')
        False
        >>> Tagger.is_version_tag('v1.2.3')
        False
        """
        return bool(cls.RE_VERSION.search(tag))

    @classmethod
    def is_id_tag(cls, tag: str) -> bool:
        """
        Returns whether tag is a commit or job tag.

        >>> Tagger.is_id_tag('git-abc123df')
        True
        >>> Tagger.is_id_tag('ci-123456789')
        True
        """
        return bool(cls.RE_ID_TAG.search(tag))

    @classmethod
    def is_env_tag(cls, tag: str) -> bool:
        return bool(cls.RE_ENV.search(tag))

    @classmethod
    def is_rotating_tag(cls, tag: str) -> bool:
        """
        Returns whether tag is a rotating tag.

        >>> Tagger.is_rotating_tag('latest-build')
        True
        >>> Tagger.is_rotating_tag('latest-bob')
        False
        """
        return bool(cls.RE_ROTATING.search(tag))

    @classmethod
    def is_special_tag(cls, tag: str) -> bool:
        return (
            cls.is_id_tag(tag)
            or cls.is_version_tag(tag)
            or cls.is_env_tag(tag)
            or cls.is_rotating_tag(tag)
        )

    @classmethod
    def is_restricted_tag(cls, tag: str) -> bool:
        """
        Returns True if a tag "looks like" a special tag.

        Only non-restricted tags are free for general use
        (all special tags are automatic).

        >>> Tagger.is_restricted_tag('latest-gossip')
        True
        >>> Tagger.is_restricted_tag('produce')
        False
        >>> Tagger.is_restricted_tag('dev-new_feature')
        True
        >>> Tagger.is_restricted_tag('development-new_feature')
        False
        >>> Tagger.is_restricted_tag('v1.2.3')
        False
        """
        return bool(cls.RE_RESTRICTED.search(tag))

    @classmethod
    def sort_env_tags(cls, tags: List[str]) -> List[str]:
        """
        Sort env tags by env order

        >>> Tagger.sort_env_tags(['prod-123', 'dev-234', 'build-345', 'uat-456'])
        ['build-345', 'dev-234', 'uat-456', 'prod-123']
        """
        return sorted(tags, key=lambda x: (ENVIRONMENTS.index(x.split("-")[0]), x))

    @classmethod
    def sort_rotating_tags(cls, tags: List[str]) -> List[str]:
        """
        Sort latest tags by env order

        >>> Tagger.sort_rotating_tags(['latest-prod-1', 'latest-dev-2', 'latest-build', 'latest-uat-4'])
        ['latest-build', 'latest-dev-2', 'latest-uat-4', 'latest-prod-1']
        """
        return sorted(tags, key=lambda x: (ENVIRONMENTS.index(x.split("-")[1]), x))

    @classmethod
    def sort_version_tags(cls, tags: List[str]) -> List[str]:
        return sorted(tags, key=SemVers, reverse=True)

    def cmd_get_tags(self) -> List[str]:
        return self._get_tags(self.args.image_tag)

    def _get_tags(self, tag: str) -> List[str]:
        try:
            response = self.client.describe_images(
                registryId=self.args.registry,
                repositoryName=self.args.repository,
                imageIds=[{"imageTag": tag}],
            )
            self.debug(f"get_tags: {response}")
        except self.client.exceptions.ImageNotFoundException:
            raise ValueError(f"Tag not found: {tag}")
        return sorted(response["imageDetails"][0]["imageTags"])

    def cmd_tag_exists(self) -> None:
        sys.exit(0 if self._tag_exists(self.args.image_tag) else 1)

    def _tag_exists(self, image_tag: str) -> bool:
        try:
            self._get_tags(image_tag)
        except ValueError:
            return False
        else:
            return True

    def cmd_tag_is_freestyle(self) -> None:
        sys.exit(0 if not self.is_restricted_tag(self.args.image_tag) else 1)

    def cmd_add_tag(self) -> str:
        if self.is_restricted_tag(self.args.new_tag):
            # version tag
            if not self.is_version_tag(self.args.new_tag):
                raise ValueError(f"Tag is not a Sematic Version: {self.args.new_tag}")
            if self.args.mutable == MutabilityOpts.YES:
                raise ValueError(f"Version tag can not be mutable: {self.args.new_tag}")
            mutable = False
        else:
            # free style
            mutable = self.args.mutable in [MutabilityOpts.YES, MutabilityOpts.AUTO]
        if not mutable and self._tag_exists(self.args.new_tag):
            raise ValueError(f"Tag exists: {self.args.new_tag}")
        return self._add_tag(self.args.image_tag, self.args.new_tag, mutable)

    def _add_tag(self, image_tag: str, new_tag: str, switch_mutability=False) -> str:

        try:
            response = self.client.batch_get_image(
                registryId=self.args.registry,
                repositoryName=self.args.repository,
                imageIds=[{"imageTag": image_tag}],
                acceptedMediaTypes=[
                    "application/vnd.docker.distribution.manifest.v2+json"
                ],
            )
            self.debug(response)
            manifest = response["images"][0]["imageManifest"]
        except IndexError:
            raise ValueError(f"Tag not found: {image_tag}")

        if switch_mutability:
            with self.immutability_turned_off():
                response = self.client.put_image(
                    registryId=self.args.registry,
                    repositoryName=self.args.repository,
                    imageManifest=manifest,
                    imageTag=new_tag,
                )
                self.debug(response)
        else:
            response = self.client.put_image(
                registryId=self.args.registry,
                repositoryName=self.args.repository,
                imageManifest=manifest,
                imageTag=new_tag,
            )
            self.debug(response)
        return new_tag

    @contextlib.contextmanager
    def immutability_turned_off(self):
        response = self.client.put_image_tag_mutability(
            registryId=self.args.registry,
            repositoryName=self.args.repository,
            imageTagMutability="MUTABLE",
        )
        self.debug(response)
        yield
        response = self.client.put_image_tag_mutability(
            registryId=self.args.registry,
            repositoryName=self.args.repository,
            imageTagMutability="IMMUTABLE",
        )
        self.debug(response)

    def cmd_add_env_tag(self) -> str:
        new_tags = []

        existing_tags = self.cmd_get_tags()
        same_env = [tag for tag in existing_tags if tag.startswith(f"{self.args.env}-")]
        if same_env:
            new_tags.append(same_env[0])
        else:
            new_tag = f"{self.args.env}-{self.timestamp()}"
            self._add_tag(self.args.image_tag, new_tag)
            new_tags.append(new_tag)

        if self.args.add_latest > 0:
            if self.args.add_latest == 1:
                latest_tags = [f"latest-{self.args.env}"]
                delete_tags = [
                    f"latest-{self.args.env}-{n}" for n in range(self.MAX_ROTATING_TAGS)
                ]
            else:
                latest_tags = [
                    f"latest-{self.args.env}-{n}" for n in range(self.args.add_latest)
                ]
                delete_tags = [f"latest-{self.args.env}"] + [
                    f"latest-{self.args.env}-{n}"
                    for n in range(self.args.add_latest, self.MAX_ROTATING_TAGS)
                ]
            if latest_tags[0] not in existing_tags:  # deploying the same image again?
                with self.immutability_turned_off():
                    self._shift_tags([self.args.image_tag] + latest_tags)
                self._delete_tags(delete_tags)
                new_tags.append(latest_tags[0])

        return " ".join(new_tags)

    def _shift_tags(self, tags: List[str]):
        """
        Adds labels[i+1] to image labels[i]
        """
        if len(tags) < 2:
            return
        for i in range(len(tags) - 1, 0, -1):
            old_owner = tags[i]
            new_owner = tags[i - 1]
            if self._tag_exists(new_owner):
                try:
                    self._add_tag(new_owner, old_owner)
                except self.client.exceptions.ImageAlreadyExistsException as exc:
                    # inconsistent state due to exception in a previous run,
                    # like latest-0, latest-1 on the same image
                    print(f"{exc.__class__.__name__}: {exc}", file=sys.stderr)

    def _delete_tags(self, tags: List[str]):
        response = self.client.batch_delete_image(
            registryId=self.args.registry,
            repositoryName=self.args.repository,
            imageIds=[{"imageTag": tag} for tag in tags],
        )
        self.debug(response)

    def cmd_validate_version(self):
        try:
            if not self.is_version_tag(self.args.version):
                raise ValueError(
                    f"not a valid simplified semantic version: {self.args.version}"
                )
            pre_release_type = SemVers(self.args.version).pre_release_type
            if self.args.no_alpha and pre_release_type == "alpha":
                raise ValueError(
                    f"alpha pre-release versions are not allowed: {self.args.version}"
                )
            if self.args.no_beta and pre_release_type == "beta":
                raise ValueError(
                    f"beta pre-release versions are not allowed: {self.args.version}"
                )
            if self.args.no_rc and pre_release_type == "rc":
                raise ValueError(
                    f"rc pre-release versions are not allowed: {self.args.version}"
                )
        except ValueError as exc:
            print(exc, file=sys.stderr)
            sys.exit(os.EX_DATAERR)

    def cmd_list_tags(self) -> None:
        response = self.client.describe_images(
            registryId=self.args.registry, repositoryName=self.args.repository
        )
        images = sorted(
            [
                Image(pushed_at=x["imagePushedAt"], tags=sorted(x["imageTags"]))
                for x in response["imageDetails"]
            ],
            key=lambda x: x.pushed_at,
            reverse=True,
        )

        headers = [
            "Pushed",
            "Versions",
            "Commit",
            "First deployed",
            "Latest deployed",
            "Others",
        ]
        data = [
            [
                image.pushed_at.strftime("%Y%m%d-%H%M%S"),
                " ".join(self.sort_version_tags(image.versions)),
                " ".join(image.id_tags),
                " ".join(self.sort_env_tags(image.env_tags)),
                " ".join(self.sort_rotating_tags(image.latest_tags)),
                " ".join(image.other_tags),
            ]
            for image in images
        ]
        table = [headers] + data

        if not self.args.verbose:
            table = [itemgetter(1, 4)(x) for x in table]

        self.print_table(table)

    # noinspection StrFormat
    @staticmethod
    def print_table(data: List[List[str]]):
        widths = [0] * len(data[0])
        for c in range(len(widths)):
            widths[c] = max(len(row[c]) for row in data)
        row_format = " | ".join([f"{{:<{widths[c]}}}" for c in range(len(widths))])

        print(row_format.format(*data[0]))
        print(row_format.format(*["=" * w for w in widths]).replace(" ", "="))
        for row in data[1:]:
            print(row_format.format(*row))

    def cmd_selftest(self):
        import doctest

        doctest.testmod(exclude_empty=True, verbose=self.args.verbose)

    def run(self):
        if (result := self.args.func()) is not None:
            print(result)


def main():
    tagger = Tagger(sys.argv[1:])
    if tagger.args.debug:
        tagger.run()
        sys.exit(os.EX_OK)
    try:
        tagger.run()
    except ValueError as exc:
        print(f"{exc.__class__.__name__}: {exc}", file=sys.stderr)
        sys.exit(os.EX_DATAERR)
    except Exception as exc:
        print(f"{exc.__class__.__name__}: {exc}", file=sys.stderr)
        sys.exit(os.EX_SOFTWARE)
    else:
        sys.exit(os.EX_OK)


if __name__ == "__main__":
    main()
    # import cProfile
    # cProfile.run('main()', sort='cumtime')
